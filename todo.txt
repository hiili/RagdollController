Turn it into an actor component library. By default, components auto-detect needed other components from the same Actor (eg, skelmesh), and from the world's actors (eg, a remote control interface).
This can be overrided, so as to have the components connect with given other components. Provide also a RedetectComponents() method for re-scanning for default targets. Possible components:
  - SkeletalMeshComponent controller (implements SensorInterface and ActuatorInterface):
    Reads from and writes to a single SkeletalMeshComponent. Default: owning Actor's only skelmesh.
  - Sensory components (implements SensorInterface, and maybe ActuatorInterface in case of active perception / controllable scene queries):
    Query information from the scene around the actor (passive or active querying).
  - RemoteControlHub component/actor:
    Manages a single TCP port for external comms (a Matlab controller at this point). Can be embedded into a global placeholder actor, and comes with a convenience wrapper actor for directly dropping one into the scene.
  - RemoteControlRelay component (implements RemoteControllable, autodetects local sensors and actuators): 
    Connects with local sensors and actuators, and waits for an inbound control connection (relayed via the RemoteControlHub)
  - LocalController component (autodetects local sensors and actuators):
    An alternative to the RemoteControlRelay component, operates directly all local (or explicitly connected) sensors and actuators.
  - ReplicatePose component: Server->Client pose replication system.
    Might extend some day to somehow manage full networked physics interactions ('distributed physics simulation'?). (Will need to re-think from ground up what it means to sync actions and to have "authority" over events.)


cosmetic
--------

drop the this-> convention, see https://stackoverflow.com/questions/1228161/why-use-prefixes-on-member-variables-in-c-classes and https://stackoverflow.com/questions/111605/what-kind-of-prefix-do-you-use-for-member-variables

think out the naming conventions. At the moment:
  - methods are loCamelCase, member variables are HiCamelCase, arguments and local variables are loCamelCase. Not too logical..
  - UE-style would be to use HiCamelCase also with methods.
  - Style-to-apply: All methods and member variables are HiCamelCase, while local variables and possible local functions are loCamelCase. Once implemented, you can drop the this-> convention.
